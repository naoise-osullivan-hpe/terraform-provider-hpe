// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package instance

import (
	"context"
	"fmt"
	"github.com/HPE/terraform-provider-hpe/internal/subproviders/morpheus/morpheusvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func InstanceResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"cloud_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The Cloud ID to provision the instance onto.",
				MarkdownDescription: "The Cloud ID to provision the instance onto.",
			},
			"config": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Configuration object. Settings vary by type. (Dynamic)",
				MarkdownDescription: "Configuration object. Settings vary by type. (Dynamic)",
				Validators: []validator.String{
					morpheusvalidators.JSONValidator{},
				},
			},
			"evars": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"value": schema.StringAttribute{
							Required:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: EvarsType{
						ObjectType: types.ObjectType{
							AttrTypes: EvarsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Environment Variables, an array of objects that have name and value.",
				MarkdownDescription: "Environment Variables, an array of objects that have name and value.",
			},
			"group_id": schema.Int64Attribute{
				Required:            true,
				Description:         "The Group ID to provision the instance into.",
				MarkdownDescription: "The Group ID to provision the instance into.",
			},
			"id": schema.Int64Attribute{
				Computed: true,
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"instance_context": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Environment",
				MarkdownDescription: "Environment",
			},
			"instance_type_id": schema.Int64Attribute{
				Required:            true,
				Description:         "The type of instance by id we want to fetch.",
				MarkdownDescription: "The type of instance by id we want to fetch.",
			},
			"layout_id": schema.Int64Attribute{
				Required:            true,
				Description:         "The layout id for the instance type that you want to provision. i.e. single process or cluster",
				MarkdownDescription: "The layout id for the instance type that you want to provision. i.e. single process or cluster",
			},
			"layout_size": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Apply a multiply factor of containers/vms within the instance.",
				MarkdownDescription: "Apply a multiply factor of containers/vms within the instance.",
				Default:             int64default.StaticInt64(1),
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the instance to be created.",
				MarkdownDescription: "Name of the instance to be created.",
			},
			"network_interfaces": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"ip_address": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The ip address. Not applicable when using DHCP or IP Pools.",
							MarkdownDescription: "The ip address. Not applicable when using DHCP or IP Pools.",
						},
						"ip_mode": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The mode for determining ip address. Use 'static' when specifying an ipAddress, otherwise 'dhcp' is used.",
							MarkdownDescription: "The mode for determining ip address. Use 'static' when specifying an ipAddress, otherwise 'dhcp' is used.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"static",
									"dhcp",
								),
							},
							Default: stringdefault.StaticString("dhcp"),
						},
						"network_group_id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "id of the network group to be used.",
							MarkdownDescription: "id of the network group to be used.",
							Validators: []validator.Int64{
								int64validator.ConflictsWith(path.Expressions{
									path.MatchRoot("network_id"),
								}...),
							},
						},
						"network_id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "id of the network to be used.",
							MarkdownDescription: "id of the network to be used.",
						},
					},
					CustomType: NetworkInterfacesType{
						ObjectType: types.ObjectType{
							AttrTypes: NetworkInterfacesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The networkInterfaces parameter is for network configuration.\n\nThe Options API \"/api/options/zoneNetworkOptions?zoneId=5&provisionTypeId=10\" can be used to see which options are available.\n",
				MarkdownDescription: "The networkInterfaces parameter is for network configuration.\n\nThe Options API \"/api/options/zoneNetworkOptions?zoneId=5&provisionTypeId=10\" can be used to see which options are available.\n",
			},
			"plan_id": schema.Int64Attribute{
				Required:            true,
				Description:         "The id for the memory and storage option pre-configured within Morpheus.",
				MarkdownDescription: "The id for the memory and storage option pre-configured within Morpheus.",
			},
			"ports": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"load_balancer_protocol": schema.StringAttribute{
							Optional:            true,
							Description:         "Enable a load balancer and set load balancer protocol. HTTP, HTTPS, or TCP.",
							MarkdownDescription: "Enable a load balancer and set load balancer protocol. HTTP, HTTPS, or TCP.",
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "A name for the port.",
							MarkdownDescription: "A name for the port.",
						},
						"port": schema.Int64Attribute{
							Required:            true,
							Description:         "Port number.",
							MarkdownDescription: "Port number.",
						},
					},
					CustomType: PortsType{
						ObjectType: types.ObjectType{
							AttrTypes: PortsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "The ports parameter is for port configuration.\n\nThe layout may have default ports, which are defined in node types, that are always configured. This parameter will be for additional custom ports to be opened.\n",
				MarkdownDescription: "The ports parameter is for port configuration.\n\nThe layout may have default ports, which are defined in node types, that are always configured. This parameter will be for additional custom ports to be opened.\n",
			},
			"tags": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:            true,
							Description:         "",
							MarkdownDescription: "",
						},
						"value": schema.StringAttribute{
							Required:            true,
							Description:         "",
							MarkdownDescription: "",
						},
					},
					CustomType: TagsType{
						ObjectType: types.ObjectType{
							AttrTypes: TagsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Metadata tags, Array of objects having a name and value.",
				MarkdownDescription: "Metadata tags, Array of objects having a name and value.",
			},
			"task_set_id": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "The Workflow ID to execute.",
				MarkdownDescription: "The Workflow ID to execute.",
			},
			"volumes": schema.SetNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"controller_mount_point": schema.StringAttribute{
							Optional:            true,
							Description:         "The controller mount point specification for this volume in the format:\n  \"id:busNumber:typeId:unitNumber\"\nFor new storage controllers the id is passed as -1, so an example value would be:\n  \"-1:1:6:0\"\nwhich translates to id: -1 (new), busNumber: 1, storage controller type id: 6 (SCSI VMware Paravirtual), unit number: 0.\nThe current list of storage controllers is returned for instances and servers for determining existing id values.\nUse /api/provision-types?code=vmware to see the available controllerTypes for vmware.\"\n",
							MarkdownDescription: "The controller mount point specification for this volume in the format:\n  \"id:busNumber:typeId:unitNumber\"\nFor new storage controllers the id is passed as -1, so an example value would be:\n  \"-1:1:6:0\"\nwhich translates to id: -1 (new), busNumber: 1, storage controller type id: 6 (SCSI VMware Paravirtual), unit number: 0.\nThe current list of storage controllers is returned for instances and servers for determining existing id values.\nUse /api/provision-types?code=vmware to see the available controllerTypes for vmware.\"\n",
						},
						"datastore_auto_selection": schema.StringAttribute{
							Optional:            true,
							Description:         "Auto selection can be specified as auto or autoCluster (for clusters).",
							MarkdownDescription: "Auto selection can be specified as auto or autoCluster (for clusters).",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"auto",
									"autoCluster",
								),
							},
						},
						"datastore_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "The ID of the specific datastore.",
							MarkdownDescription: "The ID of the specific datastore.",
						},
						"id": schema.Int64Attribute{
							Optional:            true,
							Computed:            true,
							Description:         "The id for the LV configuration being created.",
							MarkdownDescription: "The id for the LV configuration being created.",
							Default:             int64default.StaticInt64(-1),
						},
						"name": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "Name/type of the LV being created.",
							MarkdownDescription: "Name/type of the LV being created.",
							Default:             stringdefault.StaticString("root"),
						},
						"root_volume": schema.BoolAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "If set to false then a non-root LV will be created.",
							MarkdownDescription: "If set to false then a non-root LV will be created.",
							Default:             booldefault.StaticBool(true),
						},
						"size": schema.Int64Attribute{
							Optional:            true,
							Description:         "Size of the LV to be created in GBs.  Uses default from service plan.",
							MarkdownDescription: "Size of the LV to be created in GBs.  Uses default from service plan.",
						},
						"size_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "Can be used to select pre-existing LV choices from Morpheus.",
							MarkdownDescription: "Can be used to select pre-existing LV choices from Morpheus.",
						},
						"storage_type_id": schema.Int64Attribute{
							Optional:            true,
							Description:         "Identifier for LV type",
							MarkdownDescription: "Identifier for LV type",
						},
					},
					CustomType: VolumesType{
						ObjectType: types.ObjectType{
							AttrTypes: VolumesValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Logical Volume configuration to create additional LVs at provision time",
				MarkdownDescription: "Logical Volume configuration to create additional LVs at provision time",
			},
		},
	}
}

type InstanceModel struct {
	CloudId           types.Int64  `tfsdk:"cloud_id"`
	Config            types.String `tfsdk:"config"`
	Evars             types.Set    `tfsdk:"evars"`
	GroupId           types.Int64  `tfsdk:"group_id"`
	Id                types.Int64  `tfsdk:"id"`
	InstanceContext   types.String `tfsdk:"instance_context"`
	InstanceTypeId    types.Int64  `tfsdk:"instance_type_id"`
	LayoutId          types.Int64  `tfsdk:"layout_id"`
	LayoutSize        types.Int64  `tfsdk:"layout_size"`
	Name              types.String `tfsdk:"name"`
	NetworkInterfaces types.Set    `tfsdk:"network_interfaces"`
	PlanId            types.Int64  `tfsdk:"plan_id"`
	Ports             types.Set    `tfsdk:"ports"`
	Tags              types.Set    `tfsdk:"tags"`
	TaskSetId         types.Int64  `tfsdk:"task_set_id"`
	Volumes           types.Set    `tfsdk:"volumes"`
}

var _ basetypes.ObjectTypable = EvarsType{}

type EvarsType struct {
	basetypes.ObjectType
}

func (t EvarsType) Equal(o attr.Type) bool {
	other, ok := o.(EvarsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvarsType) String() string {
	return "EvarsType"
}

func (t EvarsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if in.IsUnknown() {
		return NewEvarsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvarsValueNull(), nil
	}

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvarsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEvarsValueNull() EvarsValue {
	return EvarsValue{
		state: attr.ValueStateNull,
	}
}

func NewEvarsValueUnknown() EvarsValue {
	return EvarsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvarsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvarsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvarsValue Attribute Value",
				"While creating a EvarsValue value, a missing attribute value was detected. "+
					"A EvarsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvarsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvarsValue Attribute Type",
				"While creating a EvarsValue value, an invalid attribute value was detected. "+
					"A EvarsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvarsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvarsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvarsValue Attribute Value",
				"While creating a EvarsValue value, an extra attribute value was detected. "+
					"A EvarsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvarsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvarsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewEvarsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewEvarsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewEvarsValueUnknown(), diags
	}

	return EvarsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewEvarsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvarsValue {
	object, diags := NewEvarsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvarsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvarsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvarsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvarsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvarsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvarsValueMust(EvarsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvarsType) ValueType(ctx context.Context) attr.Value {
	return EvarsValue{}
}

var _ basetypes.ObjectValuable = EvarsValue{}

type EvarsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v EvarsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvarsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvarsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvarsValue) String() string {
	return "EvarsValue"
}

func (v EvarsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v EvarsValue) Equal(o attr.Value) bool {
	other, ok := o.(EvarsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v EvarsValue) Type(ctx context.Context) attr.Type {
	return EvarsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvarsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NetworkInterfacesType{}

type NetworkInterfacesType struct {
	basetypes.ObjectType
}

func (t NetworkInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(NetworkInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NetworkInterfacesType) String() string {
	return "NetworkInterfacesType"
}

func (t NetworkInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if in.IsUnknown() {
		return NewNetworkInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkInterfacesValueNull(), nil
	}

	attributes := in.Attributes()

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return nil, diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	ipModeAttribute, ok := attributes["ip_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mode is missing from object`)

		return nil, diags
	}

	ipModeVal, ok := ipModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mode expected to be basetypes.StringValue, was: %T`, ipModeAttribute))
	}

	networkGroupIdAttribute, ok := attributes["network_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_group_id is missing from object`)

		return nil, diags
	}

	networkGroupIdVal, ok := networkGroupIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_group_id expected to be basetypes.Int64Value, was: %T`, networkGroupIdAttribute))
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return nil, diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.Int64Value, was: %T`, networkIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NetworkInterfacesValue{
		IpAddress:      ipAddressVal,
		IpMode:         ipModeVal,
		NetworkGroupId: networkGroupIdVal,
		NetworkId:      networkIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNetworkInterfacesValueNull() NetworkInterfacesValue {
	return NetworkInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewNetworkInterfacesValueUnknown() NetworkInterfacesValue {
	return NetworkInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNetworkInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NetworkInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NetworkInterfacesValue Attribute Value",
				"While creating a NetworkInterfacesValue value, a missing attribute value was detected. "+
					"A NetworkInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NetworkInterfacesValue Attribute Type",
				"While creating a NetworkInterfacesValue value, an invalid attribute value was detected. "+
					"A NetworkInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NetworkInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NetworkInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NetworkInterfacesValue Attribute Value",
				"While creating a NetworkInterfacesValue value, an extra attribute value was detected. "+
					"A NetworkInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NetworkInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNetworkInterfacesValueUnknown(), diags
	}

	ipAddressAttribute, ok := attributes["ip_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_address is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	ipAddressVal, ok := ipAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_address expected to be basetypes.StringValue, was: %T`, ipAddressAttribute))
	}

	ipModeAttribute, ok := attributes["ip_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mode is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	ipModeVal, ok := ipModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mode expected to be basetypes.StringValue, was: %T`, ipModeAttribute))
	}

	networkGroupIdAttribute, ok := attributes["network_group_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_group_id is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	networkGroupIdVal, ok := networkGroupIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_group_id expected to be basetypes.Int64Value, was: %T`, networkGroupIdAttribute))
	}

	networkIdAttribute, ok := attributes["network_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`network_id is missing from object`)

		return NewNetworkInterfacesValueUnknown(), diags
	}

	networkIdVal, ok := networkIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`network_id expected to be basetypes.Int64Value, was: %T`, networkIdAttribute))
	}

	if diags.HasError() {
		return NewNetworkInterfacesValueUnknown(), diags
	}

	return NetworkInterfacesValue{
		IpAddress:      ipAddressVal,
		IpMode:         ipModeVal,
		NetworkGroupId: networkGroupIdVal,
		NetworkId:      networkIdVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewNetworkInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NetworkInterfacesValue {
	object, diags := NewNetworkInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNetworkInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NetworkInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNetworkInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNetworkInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNetworkInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNetworkInterfacesValueMust(NetworkInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NetworkInterfacesType) ValueType(ctx context.Context) attr.Value {
	return NetworkInterfacesValue{}
}

var _ basetypes.ObjectValuable = NetworkInterfacesValue{}

type NetworkInterfacesValue struct {
	IpAddress      basetypes.StringValue `tfsdk:"ip_address"`
	IpMode         basetypes.StringValue `tfsdk:"ip_mode"`
	NetworkGroupId basetypes.Int64Value  `tfsdk:"network_group_id"`
	NetworkId      basetypes.Int64Value  `tfsdk:"network_id"`
	state          attr.ValueState
}

func (v NetworkInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["ip_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_mode"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["network_group_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["network_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.IpAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_address"] = val

		val, err = v.IpMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mode"] = val

		val, err = v.NetworkGroupId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_group_id"] = val

		val, err = v.NetworkId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["network_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NetworkInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NetworkInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NetworkInterfacesValue) String() string {
	return "NetworkInterfacesValue"
}

func (v NetworkInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_address":       basetypes.StringType{},
		"ip_mode":          basetypes.StringType{},
		"network_group_id": basetypes.Int64Type{},
		"network_id":       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_address":       v.IpAddress,
			"ip_mode":          v.IpMode,
			"network_group_id": v.NetworkGroupId,
			"network_id":       v.NetworkId,
		})

	return objVal, diags
}

func (v NetworkInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(NetworkInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpAddress.Equal(other.IpAddress) {
		return false
	}

	if !v.IpMode.Equal(other.IpMode) {
		return false
	}

	if !v.NetworkGroupId.Equal(other.NetworkGroupId) {
		return false
	}

	if !v.NetworkId.Equal(other.NetworkId) {
		return false
	}

	return true
}

func (v NetworkInterfacesValue) Type(ctx context.Context) attr.Type {
	return NetworkInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NetworkInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_address":       basetypes.StringType{},
		"ip_mode":          basetypes.StringType{},
		"network_group_id": basetypes.Int64Type{},
		"network_id":       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PortsType{}

type PortsType struct {
	basetypes.ObjectType
}

func (t PortsType) Equal(o attr.Type) bool {
	other, ok := o.(PortsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PortsType) String() string {
	return "PortsType"
}

func (t PortsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if in.IsUnknown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := in.Attributes()

	loadBalancerProtocolAttribute, ok := attributes["load_balancer_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_protocol is missing from object`)

		return nil, diags
	}

	loadBalancerProtocolVal, ok := loadBalancerProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_protocol expected to be basetypes.StringValue, was: %T`, loadBalancerProtocolAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return nil, diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PortsValue{
		LoadBalancerProtocol: loadBalancerProtocolVal,
		Name:                 nameVal,
		Port:                 portVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortsValueNull() PortsValue {
	return PortsValue{
		state: attr.ValueStateNull,
	}
}

func NewPortsValueUnknown() PortsValue {
	return PortsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPortsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PortsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PortsValue Attribute Value",
				"While creating a PortsValue value, a missing attribute value was detected. "+
					"A PortsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PortsValue Attribute Type",
				"While creating a PortsValue value, an invalid attribute value was detected. "+
					"A PortsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PortsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PortsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PortsValue Attribute Value",
				"While creating a PortsValue value, an extra attribute value was detected. "+
					"A PortsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PortsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	loadBalancerProtocolAttribute, ok := attributes["load_balancer_protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`load_balancer_protocol is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	loadBalancerProtocolVal, ok := loadBalancerProtocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`load_balancer_protocol expected to be basetypes.StringValue, was: %T`, loadBalancerProtocolAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	portAttribute, ok := attributes["port"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`port is missing from object`)

		return NewPortsValueUnknown(), diags
	}

	portVal, ok := portAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`port expected to be basetypes.Int64Value, was: %T`, portAttribute))
	}

	if diags.HasError() {
		return NewPortsValueUnknown(), diags
	}

	return PortsValue{
		LoadBalancerProtocol: loadBalancerProtocolVal,
		Name:                 nameVal,
		Port:                 portVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPortsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PortsValue {
	object, diags := NewPortsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPortsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PortsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPortsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPortsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPortsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPortsValueMust(PortsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PortsType) ValueType(ctx context.Context) attr.Value {
	return PortsValue{}
}

var _ basetypes.ObjectValuable = PortsValue{}

type PortsValue struct {
	LoadBalancerProtocol basetypes.StringValue `tfsdk:"load_balancer_protocol"`
	Name                 basetypes.StringValue `tfsdk:"name"`
	Port                 basetypes.Int64Value  `tfsdk:"port"`
	state                attr.ValueState
}

func (v PortsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["load_balancer_protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["port"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LoadBalancerProtocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["load_balancer_protocol"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Port.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["port"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PortsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PortsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PortsValue) String() string {
	return "PortsValue"
}

func (v PortsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"load_balancer_protocol": basetypes.StringType{},
		"name":                   basetypes.StringType{},
		"port":                   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"load_balancer_protocol": v.LoadBalancerProtocol,
			"name":                   v.Name,
			"port":                   v.Port,
		})

	return objVal, diags
}

func (v PortsValue) Equal(o attr.Value) bool {
	other, ok := o.(PortsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LoadBalancerProtocol.Equal(other.LoadBalancerProtocol) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Port.Equal(other.Port) {
		return false
	}

	return true
}

func (v PortsValue) Type(ctx context.Context) attr.Type {
	return PortsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PortsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"load_balancer_protocol": basetypes.StringType{},
		"name":                   basetypes.StringType{},
		"port":                   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = TagsType{}

type TagsType struct {
	basetypes.ObjectType
}

func (t TagsType) Equal(o attr.Type) bool {
	other, ok := o.(TagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TagsType) String() string {
	return "TagsType"
}

func (t TagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if in.IsUnknown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return nil, diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TagsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueNull() TagsValue {
	return TagsValue{
		state: attr.ValueStateNull,
	}
}

func NewTagsValueUnknown() TagsValue {
	return TagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TagsValue Attribute Value",
				"While creating a TagsValue value, a missing attribute value was detected. "+
					"A TagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TagsValue Attribute Type",
				"While creating a TagsValue value, an invalid attribute value was detected. "+
					"A TagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TagsValue Attribute Value",
				"While creating a TagsValue value, an extra attribute value was detected. "+
					"A TagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	valueAttribute, ok := attributes["value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	valueVal, ok := valueAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value expected to be basetypes.StringValue, was: %T`, valueAttribute))
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	return TagsValue{
		Name:  nameVal,
		Value: valueVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TagsValue {
	object, diags := NewTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTagsValueMust(TagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TagsType) ValueType(ctx context.Context) attr.Value {
	return TagsValue{}
}

var _ basetypes.ObjectValuable = TagsValue{}

type TagsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Value basetypes.StringValue `tfsdk:"value"`
	state attr.ValueState
}

func (v TagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Value.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TagsValue) String() string {
	return "TagsValue"
}

func (v TagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":  v.Name,
			"value": v.Value,
		})

	return objVal, diags
}

func (v TagsValue) Equal(o attr.Value) bool {
	other, ok := o.(TagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Value.Equal(other.Value) {
		return false
	}

	return true
}

func (v TagsValue) Type(ctx context.Context) attr.Type {
	return TagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name":  basetypes.StringType{},
		"value": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VolumesType{}

type VolumesType struct {
	basetypes.ObjectType
}

func (t VolumesType) Equal(o attr.Type) bool {
	other, ok := o.(VolumesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VolumesType) String() string {
	return "VolumesType"
}

func (t VolumesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	if in.IsUnknown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := in.Attributes()

	controllerMountPointAttribute, ok := attributes["controller_mount_point"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`controller_mount_point is missing from object`)

		return nil, diags
	}

	controllerMountPointVal, ok := controllerMountPointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`controller_mount_point expected to be basetypes.StringValue, was: %T`, controllerMountPointAttribute))
	}

	datastoreAutoSelectionAttribute, ok := attributes["datastore_auto_selection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datastore_auto_selection is missing from object`)

		return nil, diags
	}

	datastoreAutoSelectionVal, ok := datastoreAutoSelectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datastore_auto_selection expected to be basetypes.StringValue, was: %T`, datastoreAutoSelectionAttribute))
	}

	datastoreIdAttribute, ok := attributes["datastore_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datastore_id is missing from object`)

		return nil, diags
	}

	datastoreIdVal, ok := datastoreIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datastore_id expected to be basetypes.Int64Value, was: %T`, datastoreIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rootVolumeAttribute, ok := attributes["root_volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_volume is missing from object`)

		return nil, diags
	}

	rootVolumeVal, ok := rootVolumeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_volume expected to be basetypes.BoolValue, was: %T`, rootVolumeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return nil, diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return nil, diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.Int64Value, was: %T`, sizeIdAttribute))
	}

	storageTypeIdAttribute, ok := attributes["storage_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_type_id is missing from object`)

		return nil, diags
	}

	storageTypeIdVal, ok := storageTypeIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_type_id expected to be basetypes.Int64Value, was: %T`, storageTypeIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VolumesValue{
		ControllerMountPoint:   controllerMountPointVal,
		DatastoreAutoSelection: datastoreAutoSelectionVal,
		DatastoreId:            datastoreIdVal,
		Id:                     idVal,
		Name:                   nameVal,
		RootVolume:             rootVolumeVal,
		Size:                   sizeVal,
		SizeId:                 sizeIdVal,
		StorageTypeId:          storageTypeIdVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueNull() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateNull,
	}
}

func NewVolumesValueUnknown() VolumesValue {
	return VolumesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVolumesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VolumesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VolumesValue Attribute Value",
				"While creating a VolumesValue value, a missing attribute value was detected. "+
					"A VolumesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VolumesValue Attribute Type",
				"While creating a VolumesValue value, an invalid attribute value was detected. "+
					"A VolumesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VolumesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VolumesValue Attribute Value",
				"While creating a VolumesValue value, an extra attribute value was detected. "+
					"A VolumesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VolumesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	controllerMountPointAttribute, ok := attributes["controller_mount_point"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`controller_mount_point is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	controllerMountPointVal, ok := controllerMountPointAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`controller_mount_point expected to be basetypes.StringValue, was: %T`, controllerMountPointAttribute))
	}

	datastoreAutoSelectionAttribute, ok := attributes["datastore_auto_selection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datastore_auto_selection is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	datastoreAutoSelectionVal, ok := datastoreAutoSelectionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datastore_auto_selection expected to be basetypes.StringValue, was: %T`, datastoreAutoSelectionAttribute))
	}

	datastoreIdAttribute, ok := attributes["datastore_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datastore_id is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	datastoreIdVal, ok := datastoreIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datastore_id expected to be basetypes.Int64Value, was: %T`, datastoreIdAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	rootVolumeAttribute, ok := attributes["root_volume"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`root_volume is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	rootVolumeVal, ok := rootVolumeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`root_volume expected to be basetypes.BoolValue, was: %T`, rootVolumeAttribute))
	}

	sizeAttribute, ok := attributes["size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	sizeVal, ok := sizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size expected to be basetypes.Int64Value, was: %T`, sizeAttribute))
	}

	sizeIdAttribute, ok := attributes["size_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`size_id is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	sizeIdVal, ok := sizeIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`size_id expected to be basetypes.Int64Value, was: %T`, sizeIdAttribute))
	}

	storageTypeIdAttribute, ok := attributes["storage_type_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`storage_type_id is missing from object`)

		return NewVolumesValueUnknown(), diags
	}

	storageTypeIdVal, ok := storageTypeIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`storage_type_id expected to be basetypes.Int64Value, was: %T`, storageTypeIdAttribute))
	}

	if diags.HasError() {
		return NewVolumesValueUnknown(), diags
	}

	return VolumesValue{
		ControllerMountPoint:   controllerMountPointVal,
		DatastoreAutoSelection: datastoreAutoSelectionVal,
		DatastoreId:            datastoreIdVal,
		Id:                     idVal,
		Name:                   nameVal,
		RootVolume:             rootVolumeVal,
		Size:                   sizeVal,
		SizeId:                 sizeIdVal,
		StorageTypeId:          storageTypeIdVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVolumesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VolumesValue {
	object, diags := NewVolumesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVolumesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VolumesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVolumesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVolumesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVolumesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVolumesValueMust(VolumesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VolumesType) ValueType(ctx context.Context) attr.Value {
	return VolumesValue{}
}

var _ basetypes.ObjectValuable = VolumesValue{}

type VolumesValue struct {
	ControllerMountPoint   basetypes.StringValue `tfsdk:"controller_mount_point"`
	DatastoreAutoSelection basetypes.StringValue `tfsdk:"datastore_auto_selection"`
	DatastoreId            basetypes.Int64Value  `tfsdk:"datastore_id"`
	Id                     basetypes.Int64Value  `tfsdk:"id"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	RootVolume             basetypes.BoolValue   `tfsdk:"root_volume"`
	Size                   basetypes.Int64Value  `tfsdk:"size"`
	SizeId                 basetypes.Int64Value  `tfsdk:"size_id"`
	StorageTypeId          basetypes.Int64Value  `tfsdk:"storage_type_id"`
	state                  attr.ValueState
}

func (v VolumesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["controller_mount_point"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["datastore_auto_selection"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["datastore_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["root_volume"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["size"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["size_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["storage_type_id"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.ControllerMountPoint.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["controller_mount_point"] = val

		val, err = v.DatastoreAutoSelection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datastore_auto_selection"] = val

		val, err = v.DatastoreId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datastore_id"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.RootVolume.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["root_volume"] = val

		val, err = v.Size.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size"] = val

		val, err = v.SizeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["size_id"] = val

		val, err = v.StorageTypeId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["storage_type_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VolumesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VolumesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VolumesValue) String() string {
	return "VolumesValue"
}

func (v VolumesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"controller_mount_point":   basetypes.StringType{},
		"datastore_auto_selection": basetypes.StringType{},
		"datastore_id":             basetypes.Int64Type{},
		"id":                       basetypes.Int64Type{},
		"name":                     basetypes.StringType{},
		"root_volume":              basetypes.BoolType{},
		"size":                     basetypes.Int64Type{},
		"size_id":                  basetypes.Int64Type{},
		"storage_type_id":          basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"controller_mount_point":   v.ControllerMountPoint,
			"datastore_auto_selection": v.DatastoreAutoSelection,
			"datastore_id":             v.DatastoreId,
			"id":                       v.Id,
			"name":                     v.Name,
			"root_volume":              v.RootVolume,
			"size":                     v.Size,
			"size_id":                  v.SizeId,
			"storage_type_id":          v.StorageTypeId,
		})

	return objVal, diags
}

func (v VolumesValue) Equal(o attr.Value) bool {
	other, ok := o.(VolumesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ControllerMountPoint.Equal(other.ControllerMountPoint) {
		return false
	}

	if !v.DatastoreAutoSelection.Equal(other.DatastoreAutoSelection) {
		return false
	}

	if !v.DatastoreId.Equal(other.DatastoreId) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.RootVolume.Equal(other.RootVolume) {
		return false
	}

	if !v.Size.Equal(other.Size) {
		return false
	}

	if !v.SizeId.Equal(other.SizeId) {
		return false
	}

	if !v.StorageTypeId.Equal(other.StorageTypeId) {
		return false
	}

	return true
}

func (v VolumesValue) Type(ctx context.Context) attr.Type {
	return VolumesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VolumesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"controller_mount_point":   basetypes.StringType{},
		"datastore_auto_selection": basetypes.StringType{},
		"datastore_id":             basetypes.Int64Type{},
		"id":                       basetypes.Int64Type{},
		"name":                     basetypes.StringType{},
		"root_volume":              basetypes.BoolType{},
		"size":                     basetypes.Int64Type{},
		"size_id":                  basetypes.Int64Type{},
		"storage_type_id":          basetypes.Int64Type{},
	}
}
